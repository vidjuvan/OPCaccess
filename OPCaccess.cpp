static const char *RcsId = "$Header: /users/chaize/newsvn/cvsroot/Communication/OPCaccess/src/OPCaccess.cpp,v 1.1 2008-08-06 16:04:30 andy_gotz Exp $";
//+=============================================================================
//
// file :         OPCaccess.cpp
//
// description :  C++ source for the OPCaccess and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                OPCaccess are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author: andy_gotz $
//
// $Revision: 1.1 $
//
// $Log: not supported by cvs2svn $
// Revision 1.3  2005/09/06 16:26:07  meyer
// Ported to Tango%. Modified attribute structure!
//
// Revision 1.2  2004/11/17 15:57:16  meyer
// Update documentation and added support for OPC servers without array handling.
//
// Revision 1.1.1.1  2004/11/08 09:21:08  meyer
// Imported using TkCVS
//
// Revision 1.7  2004/11/08 09:15:18  meyer
// Changed state handling
//
// Revision 1.6  2004/10/27 14:29:19  meyer
// Tested version!
//
// Revision 1.5  2004/10/25 16:44:33  meyer
// cleaned-up
//
// Revision 1.4  2004/10/25 16:06:57  meyer
// Tested per item access.
//
// Revision 1.3  2004/10/25 10:49:05  meyer
// OPC item as structure!
//
// Revision 1.2  2004/10/22 13:51:13  meyer
// Tested Version
//
// Revision 1.1  2004/10/20 11:42:13  meyer
// Initial revision
//
//
// copyleft :     European Synchrotron Radiation Facility
//                BP 220, Grenoble 38043
//                FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


//===================================================================
//
//	The folowing table gives the correspondance
//	between commands and method's name.
//
//  Command's name|  Method's name
//	----------------------------------------
//  State       |  dev_state()
//  Status      |  dev_status()
//  ReadCache   |  read_cache()
//  ReadDirect  |  read_direct()
//
//===================================================================

#include "StdAfx.h"
#include <tango.h>
#include <OPCaccess.h>
#include <OPCaccessClass.h>
#include <OPCAttrib.h>

/////////////////////////////////////////////////////////////////////////////
// GUIDs definitions

extern "C"
{
	const IID IID_IOPCServer = {0x39c13a4d,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCServerPublicGroups = {0x39c13a4e,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCBrowseServerAddressSpace = {0x39c13a4f,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCGroupStateMgt = {0x39c13a50,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCPublicGroupStateMgt = {0x39c13a51,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCSyncIO = {0x39c13a52,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCAsyncIO = {0x39c13a53,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCItemMgt = {0x39c13a54,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IEnumOPCItemAttributes = {0x39c13a55,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
	const IID IID_IOPCDataCallback = {0x39c13a70,0x011e,0x11d0,{0x96,0x75,0x00,0x20,0xaf,0xd8,0xad,0xb3}};
}
/////////////////////////////////////////////////////////////////////////////



namespace OPCaccess_ns
{

//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::OPCaccess(string &s)
// 
// description : 	constructor for simulated OPCaccess
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
OPCaccess::OPCaccess(Tango::DeviceClass *cl,string &s):Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

OPCaccess::OPCaccess(Tango::DeviceClass *cl,const char *s):Tango::Device_4Impl(cl,s)
{
	init_device();
}

OPCaccess::OPCaccess(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void OPCaccess::delete_device()
{
	//	Delete device's allocated object

	HRESULT hr = S_OK;
	
	// Disable notification
	if ((LPUNKNOWN)m_IOPCSyncIO  &&  m_dwConnection)
	{
		CInterface<IConnectionPointContainer, &IID_IConnectionPointContainer> ConPtCont;
		CInterface<IConnectionPoint, &IID_IConnectionPoint> ConPt;
		hr = ConPtCont.Query(m_IOPCSyncIO);

		if (SUCCEEDED(hr))
		{
			hr = ConPtCont->FindConnectionPoint(IID_IOPCDataCallback, &ConPt);
		}
		if (SUCCEEDED(hr))
		{
			 hr = ConPt->Unadvise(m_dwConnection);
		}
	}

	// Release group interfaces
	if (m_IOPCItemMgt)
		m_IOPCItemMgt.Release();
	if (m_IOPCSyncIO)
		m_IOPCSyncIO.Release();
	if (m_IOPCGroupStateMgt)
		m_IOPCGroupStateMgt.Release();

	// Remove group
	if (m_hServerGroup)
	{
		m_IOPCServer->RemoveGroup(m_hServerGroup, TRUE);
	}

	// Release server
	if (m_IOPCServer)
		m_IOPCServer.Release();	
}

//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void OPCaccess::init_device()
{
	INFO_STREAM << "OPCaccess::OPCaccess() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();
	
	//	Create a Group
	//------------------------------------
	
	string group_name = devname2grpname();
	CreateGroup (server_name.c_str(), group_name.c_str());
	INFO_STREAM << "Create Groupe OK for " << group_name << endl;


	//	Create items to be read.
	//------------------------------------
	
	for (int i=0 ; i<item_names.size() ; i++)
	{		
		CreateItem (path_name.c_str(), item_names[i].c_str());
		INFO_STREAM << "Create Item OK for " << item_names[i] << endl;
	}
}


//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::readDeviceProperies()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void OPCaccess::get_device_property()
{
	//	Initialize your default values here.
	//------------------------------------------

	dataFromCache  = true;
	server_name    = "";
	path_name      = "";
	data_type 	   = "short";
	array_handling = "true";
	
	create_flag    = false;

	//	Read device properties from database.(Automatic code generation)
	//-------------------------------------------------------------
	if (Tango::Util::instance()->_UseDb==false)
		return;
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DataFromCache"));
	dev_prop.push_back(Tango::DbDatum("Server_name"));
	dev_prop.push_back(Tango::DbDatum("Path_name"));
	dev_prop.push_back(Tango::DbDatum("Item_names"));
	dev_prop.push_back(Tango::DbDatum("Data_type"));
	dev_prop.push_back(Tango::DbDatum("Array_handling"));

	//	Call database and extract values
	//--------------------------------------------
	get_db_device()->get_property(dev_prop);
	OPCaccessClass	*ds_class =
		(static_cast<OPCaccessClass *>(get_device_class()));
	int	i = -1;
	//	Extract DataFromCache value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  dataFromCache;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dataFromCache;
	}

	//	Extract Server_name value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  server_name;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  server_name;
	}

	//	Extract Path_name value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  path_name;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  path_name;
	}

	//	Extract Item_names value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  item_names;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  item_names;
	}

	//	Extract Data_type value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  data_type;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  data_type;
	}

	//	Extract Array_handling value
	if (dev_prop[++i].is_empty()==false)	dev_prop[i]  >>  array_handling;
	else
	{
		//	Try to get value from class property
		Tango::DbDatum	cl_prop = ds_class->get_class_property(dev_prop[i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  array_handling;
	}



	//	End of Automatic code generation
	//-------------------------------------------------------------
	
	// set the requeseted data type
	
	if ( data_type == "double" )
		{
		req_data_type = Tango::DEV_DOUBLE;
		}
	else
		{
		if ( data_type == "long" )
			{
			req_data_type = Tango::DEV_LONG;
			}
		else
			{
			req_data_type = Tango::DEV_SHORT;
			}
		}

	// check the use of array dat types
	
	if ( array_handling == "false" || array_handling == "no" )
		{
		use_array = false;
		}
	else
		{
		use_array = true;
		}
			
	// set the requested data source
	
	if (dataFromCache)
		data_source = OPC_DS_CACHE;
	else
		data_source = OPC_DS_DEVICE;
			
}
//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void OPCaccess::always_executed_hook()
{

}

//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::write_attr()
// 
// description : 	Write attribute values to hardware.
//
//-----------------------------------------------------------------------------
void OPCaccess::write_attr(Tango::WAttribute &attr)
{

		Tango::WAttribute &att = attr;
		string attr_name = att.get_name();

		DEBUG_STREAM << "In write_attr() for attribute name = " << attr_name << endl;		
		
		// find the corresponding OPC item
		
		for (long i=0; i<opc_items.size(); i++)
			{
			if ( attr_name == opc_items[i].attr_name )
				{
				OpcItem *item = &(opc_items[i]);
			
				if ( item->connected == (short)true )
					{
					// get the attribute write value and 
					// write the item value to the OPC server
					
					switch (item->req_data_type)
						{
						case Tango::DEV_DOUBLE:
							double double_value;
							att.get_write_value(double_value);
							WriteItem (item, double_value);
			 				break;
					
						case Tango::DEV_LONG:	
							long long_value;
							att.get_write_value(long_value);
							WriteItem (item, long_value);
							break;
					
						case Tango::DEV_SHORT:
							short short_value;
							att.get_write_value(short_value);
							WriteItem (item, short_value);							
							break;						
						}					
					}
				}
			}
}

//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::read_attr()
// 
// description : 	Extract real attribute values from
//					hardware acquisition result.
//
//-----------------------------------------------------------------------------
void OPCaccess::read_attr(Tango::Attribute &attr)
{
	string &attr_name = attr.get_name();

	DEBUG_STREAM << "In read_attr() for attribute " << attr_name << endl;
	
	long i;
	
	// find the opc item to be read
	//
	for (i=0; i<opc_items.size(); i++)
		{
		if ( attr_name == opc_items[i].attr_name )
			{
			OpcItem *item = &(opc_items[i]);
			
			if ( item->connected == (short)true )
				{
				// read the item value from the OPC server
				//
				ReadItem (item);
			
			   // Check for an error!
				//
				
				if ( SUCCEEDED(item->pErrors[0]) )
					{
					// different data reading when only using scalar data types 
					// and the use of array data types
					
					if ( use_array)
						{
						// Now read the item value from the returned SafeArray
			
						void *value_ptr;
						long ubound;
			
						SafeArrayGetUBound (item->pItemState[0].vDataValue.parray, 1, &ubound);
						SafeArrayAccessData (item->pItemState[0].vDataValue.parray, &value_ptr);
			
						// cast the data pointer to the requested data type
					
						switch (item->req_data_type)
							{
							case Tango::DEV_DOUBLE:
								attr.set_value((double *)value_ptr, (ubound+1));
			 					break;
					
							case Tango::DEV_LONG:
								attr.set_value((long *)value_ptr, (ubound+1));
								break;
					
							case Tango::DEV_SHORT:
								attr.set_value((short *)value_ptr, (ubound+1));
								break;						
							}
				
						SafeArrayUnaccessData (item->pItemState[0].vDataValue.parray);
						}
					else
						{
						// Now read the item value from the returned variant
						
						switch (item->req_data_type)
							{
							case Tango::DEV_DOUBLE:
								attr.set_value( &(item->pItemState[0].vDataValue.dblVal) );
			 					break;
					
							case Tango::DEV_LONG:
								attr.set_value( &(item->pItemState[0].vDataValue.lVal) );
								break;
					
							case Tango::DEV_SHORT:
								attr.set_value( &(item->pItemState[0].vDataValue.iVal) );
								break;
							}						
						}
						
					// get the quality of the item value and
					// set the attribute quality
					
					Tango::AttrQuality quality = Tango::ATTR_VALID;
					if ( item->pItemState[0].wQuality == OPC_QUALITY_BAD )
						{
						quality = Tango::ATTR_INVALID;
						}
					else
						{
						if ( item->pItemState[0].wQuality == OPC_QUALITY_UNCERTAIN )
							{
							quality = Tango::ATTR_ALARM;
							}
						}
					 			
					attr.set_quality (quality);
					break;
					}
				}
			
			// In case of error, return an invalid attribute value
			//	

			short dummy = 0;

			switch (item->req_data_type)
				{
				case Tango::DEV_DOUBLE:
					attr.set_value((double *)&dummy);
					break;
				
				case Tango::DEV_LONG:
					attr.set_value((long *)&dummy);
					break;
				
				case Tango::DEV_SHORT:
					attr.set_value((short *)&dummy);
					break;						
				}
			attr.set_quality (Tango::ATTR_INVALID);
			break;
			}
		}
}


//+------------------------------------------------------------------
/**
 *	method:	OPCaccess::dev_state
 *
 *	description:	method to execute "State"
 *						This command gets the device state 
 *						(stored in its <i>device_state</i> data member) 
 *						and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState OPCaccess::dev_state()
{
	Tango::DevState	argout;
	
	DEBUG_STREAM << "OPCaccess::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
	
	OPCSERVERSTATUS	*pStatus;

	// Read the status from the OPC server
	//
	
	int	res = m_IOPCServer->GetStatus (&pStatus);
	if (SUCCEEDED(res))
		{
		if ( pStatus->dwServerState == OPC_STATUS_RUNNING )
			{
			argout = Tango::ON;
			
			// check the not connected falg and the error variable of
			// the OPC items.
			// set the state to alarm if not all items are OK.
			//
	
			for (int i=0; i<opc_items.size(); i++)
				{
				if ( !opc_items[i].connected || FAILED (opc_items[i].pErrors[0]) )
					{
					argout = Tango::ALARM;
					}
				}			
			}
		else
			{
			argout = Tango::FAULT;
			}

		// free the allocated memory
		//
		
		::CoTaskMemFree(pStatus->szVendorInfo);
		::CoTaskMemFree(pStatus);
		}
	else
		{
		argout = Tango::UNKNOWN;
		}
		
	set_state(argout);
	DeviceImpl::dev_state();
					
	return get_state(); 	
}



//+------------------------------------------------------------------
/**
 *	method:	OPCaccess::dev_status
 *
 *	description:	method to execute "Status"
 *					   This command gets the device status 
 *						(stored in its <i>device_status</i> data member) 
 *						and returns it to the caller.
 *
 * @return	Status descrition
 *
 */
//+------------------------------------------------------------------
Tango::ConstDevString OPCaccess::dev_status()
{
	Tango::DevState			state;
	string						status_msg;
	
	DEBUG_STREAM << "OPCaccess::dev_status(): entering... !" << endl;

	//	Add your own code to control device here

	state = dev_state();
	
	switch (state)
		{
		case Tango::ON:
		case Tango::ALARM:
			status_msg = "The OPC server is up and running\n";
			if ( data_source == OPC_DS_CACHE)
				{
				status_msg += "Reading data from OPC data cache\n\n";
				}
			else
				{
				status_msg += "Reading data directly from OPC device\n\n";
				}
			break;
			
		// if state is fault, OPC server has problems, but is running
		case Tango::FAULT:
			status_msg = "The OPC server indicates a FAULT!\n";
			break;
		
		// if state is unknown, cannot get status from OPC server	
		case Tango::UNKNOWN:
			status_msg = "The OPC server is not answering to status request!\n";
			break;
			
		default:
			status_msg = "UHiii, we are in an unknown state. Why????\n";
			break;
		}
		
	
	// if state is alarms, check all OPC items and get the correct error
	// messages.
	
	if ( state == Tango::ALARM )
		{
		for (int i=0; i<opc_items.size(); i++)
			{
			if ( !opc_items[i].connected )
				{
				status_msg += opc_items[i].item_name + " : is not a valid OPC item\n";
				}
			if ( FAILED(opc_items[i].pErrors[0]) )
				{
				status_msg += opc_items[i].item_name + " : " + 
				       		  GetErrorString(opc_items[i].pErrors[0])+ "\n";
				} 	
			}
		}
		
	set_status (status_msg);
	
	// get the alarm messages from the attributes
	//
	
	Tango::ConstDevString	argout = DeviceImpl::dev_status();
	
	return get_status().c_str();
}





//+------------------------------------------------------------------
/**
 *	method:	OPCaccess::read_cache
 *
 *	description:	method to execute "ReadCache"
 *	Triggers reading of data from the OPC data cache.
 *
 *
 */
//+------------------------------------------------------------------
void OPCaccess::read_cache()
{
	DEBUG_STREAM << "OPCaccess::read_cache(): entering... !" << endl;

	//	Add your own code to control device here

	data_source = OPC_DS_CACHE;
	
	// change the data source on all OPC items
	
	for (int i=0; i<opc_items.size(); i++)
		{
		opc_items[i].data_source = data_source;
		}
	
}

//+------------------------------------------------------------------
/**
 *	method:	OPCaccess::read_direct
 *
 *	description:	method to execute "ReadDirect"
 *	Triggers reading of data directly from the OPC item.
 *
 *
 */
//+------------------------------------------------------------------
void OPCaccess::read_direct()
{
	DEBUG_STREAM << "OPCaccess::read_direct(): entering... !" << endl;

	//	Add your own code to control device here

	data_source = OPC_DS_DEVICE;
	
	// change the data source on all OPC items
	
	for (int i=0; i<opc_items.size(); i++)
		{
		opc_items[i].data_source = data_source;
		}	
}



//+----------------------------------------------------------------------------
//
// method : 		OPCaccess::devname2grpname()
// 
// description : 	Get device name and replace '/' by '_'.
//						It will be used for the OPC group name.
//
//-----------------------------------------------------------------------------
char *OPCaccess::devname2grpname()
{
	static 	char	*devname = NULL;
	
	DEBUG_STREAM << "OPCaccess::devname2grpname(): entering... !" << endl;
	
	if (devname!=NULL)
		delete(devname);

	devname = new char[strlen(this->get_name().c_str())+1];
	strcpy(devname, this->get_name().c_str());
	for (int i=0 ; devname[i] ; i++)
		{
		if (devname[i] == '/')
			{
			devname[i] = '_';
			}
		}
	
	return devname;
}


//***********************************************************************************
// Connect to the server
//***********************************************************************************
void OPCaccess::ConnectServer (const char *ofs_name)
{
	HRESULT hr;
	CLSID clsid;
	
	DEBUG_STREAM << "OPCaccess::ConnectServer(): entering... !" << endl;
	
	//	Copy frame str in BSTR variable

	BSTR bstrServName = (BSTR)malloc((strlen(ofs_name)+1)*sizeof(short));;
	int	i;
	for (i=0 ; ofs_name[i]!=0 ; i++)
		bstrServName[i] = ofs_name[i];
	bstrServName[i] = 0x0;

	// get server id
	
	hr = ::CLSIDFromProgID(bstrServName, &clsid);
	free(bstrServName);
	if (FAILED(hr))
		{
		CString str_error(_T(""));
		str_error.Format(_T("%X"), hr);
		ERROR_STREAM << "Unable to get the OPC server ID" << endl;
		
		TangoSys_MemStream out_stream;
		out_stream << "Unable to get the OPC server (" << ofs_name;
		out_stream << ") ID ! err: 0x" << str_error << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_TO_CONNECT_OPC",
						out_stream.str(),
						(const char *)"OPCaccess::ConnectServer()");
		}

	// Try a connection and get a ptr on the main server interface
	
	hr = ::CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IOPCServer, (LPVOID*)&m_IOPCServer);
	if (FAILED(hr))
		{
		TangoSys_MemStream out_stream;
		
		CString str_error(_T(""));
		str_error.Format(_T("%X"), hr);
		out_stream << "Unable to connect to the OPC server -- error: 0x" << str_error << endl;
		
		if (hr & REGDB_E_CLASSNOTREG)
			{
			out_stream << "A specified class is not registered in the registration database."<< endl;
			out_stream << "Also can indicate that the type of server you requested " << endl;
			out_stream << "in the CLSCTX enumeration is not registered or the values" << endl;
			out_stream << "for the server types in the registry are corrupt."<< endl;
			}
		else
			if (hr & CLASS_E_NOAGGREGATION)
				out_stream << "This class cannot be created as part of an aggregate." << endl;
			else
				out_stream << "Error unknown !!! Good luck to debug....."<< endl;

		out_stream << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_TO_CONNECT_OFS",
						out_stream.str(),
						(const char *)"OPCaccess::ConnectServer()");
		}

	//everything is OK
}

//***********************************************************************************
// Create the group
//***********************************************************************************
void OPCaccess::CreateGroup (const char *ofs_name, const char *grp_name)
{
	float fPercentDeadband = 1.0F;
	DWORD dwUpdateRate = 1000;
	HRESULT hr;
	
	strstream	strname;
	strname << grp_name << ends;
	char	*frame = strname.str();

	BSTR	bname = (BSTR)malloc((strlen(frame)+1)*sizeof(short));

	//	Copy frame str in LPCWSTR variable
	int	i;
	for (i=0 ; frame[i]!=0 ; i++)
		bname[i] = (short) frame[i];
	bname[i] = (short) 0x0;

	// Test if connected
	if (!(LPUNKNOWN)m_IOPCServer)
		{
		ConnectServer(ofs_name);
		}

	// Create a group named ESRF_GRP and set it active 
	// get a ptr on the SyncIO interface of this group 
	
	hr = m_IOPCServer->AddGroup(
					bname,
					TRUE,
					dwUpdateRate,
					(OPCHANDLE)H_CLIENT_USE,
					NULL,
					&fPercentDeadband,
					0,
					&m_hServerGroup,
					&dwUpdateRate,
					IID_IOPCSyncIO,
					(LPUNKNOWN*)&m_IOPCSyncIO);
	free(bname);
	
	if (FAILED(hr))
		{
		ERROR_STREAM << "Unable create user group  Err: " << hr << endl;
		TangoSys_MemStream out_stream;
		out_stream << "Unable create user group ! err: " << hr << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_CREATE_GROUP",
						out_stream.str(),
						(const char *)"OPCaccess::CreateGroup()");
		}

	// Query a ptr to the Item Management Interface of this group
	hr = m_IOPCItemMgt.Query(m_IOPCSyncIO);
	if (FAILED(hr))
		{
		ERROR_STREAM << "Item management interface not available for user group  Err: " << hr << endl;
		TangoSys_MemStream out_stream;
		out_stream << "Item management interface not available for user group ! err: " << hr << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_CREATE_GROUP",
						out_stream.str(),
						(const char *)"OPCaccess::CreateGroup()");
		}

	// Query a ptr to the group state management interface of this group
	hr = m_IOPCGroupStateMgt.Query(m_IOPCSyncIO);
	if (FAILED(hr))
	{
		cout << "Group management interface not available for user group  Err: " << hr << endl;
		TangoSys_MemStream out_stream;
		out_stream << "Group management interface not available for user group ! err: " << hr << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_CREATE_GROUP",
						out_stream.str(),
						(const char *)"OPCaccess::CreateGroup()");
	}

	// Get a ptr on the server IConnectionPointContainer interface (thru the group ptr)
	CInterface<IConnectionPointContainer, &IID_IConnectionPointContainer> ConPtCont;
	hr = ConPtCont.Query(m_IOPCSyncIO);
	if (FAILED(hr))
		{
		ERROR_STREAM << "Connection point not supported  Err: " << hr << endl;
		TangoSys_MemStream out_stream;
		out_stream << "Connection point not supported ! err: " << hr << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_CREATE_GROUP",
						out_stream.str(),
						(const char *)"OPCaccess::CreateGroup()");
		}


	// everything OK
}




//***********************************************************************************
// Create the OPC item with a symbole name
//***********************************************************************************
void OPCaccess::CreateItem (const char *path_name, const char *var_name)
{
	// create and initialise an item structure
	//
	OpcItem item;
	
	// initialise OPC item
	
	item.item_name 		= var_name;
	item.connected 		= false;
	item.data_source    	= data_source;
	item.itemHandle		= NULL;
	item.accessRight		= OPC_READABLE; 
	item.pErrors			= NULL;
	item.pItemState     	= NULL;
	item.last_read_time 	= 0;
	item.req_data_type 	= req_data_type;
	
	// extract the attribute name as item name without format specifiers
	
	long comma   = item.item_name.find(',');	
	if (comma == std::string::npos)
		{
		item.attr_name	= item.item_name;
		}
	else
		{
		item.attr_name	= item.item_name.substr(0,comma);
		}
	
		

	strstream	frame;
	frame << path_name << var_name << ends;

	INFO_STREAM << "frame: " << frame.str() << endl;
	BuildItem (frame.str(), &item);
	
	opc_items.push_back (item);
}


//***********************************************************************************
// Build really the item from the frame
//***********************************************************************************
void OPCaccess::BuildItem (char *frame, OpcItem *item)
{
	OPCITEMDEF ItemDef[1];
	OPCITEMRESULT* pItemResult = NULL;
	HRESULT* pErrors           = NULL;
	HRESULT hr;

	BSTR bsItem = (BSTR)malloc((strlen(frame)+1)*sizeof(short));

	//	Copy frame str in BSTR variable
	
	int	i;
	for (i=0 ; frame[i]!=0 ; i++)
		bsItem[i] = frame[i];
	bsItem[i] = 0x0;

	// Test if group already created
	
	if (!(LPUNKNOWN)m_IOPCItemMgt)
		{
		TangoSys_MemStream out_stream;
		out_stream << "Not connected to OPC server !" << ends;
		Tango::Except::throw_exception(
						(const char *)"UNABLE_CREATE_ITEM",
						out_stream.str(),
						(const char *)"OPCaccess::CreateItem()");
		}

	// Defines the user item
	ItemDef[0].szAccessPath = L"";
	ItemDef[0].szItemID     = bsItem;
	ItemDef[0].bActive      = TRUE;
	ItemDef[0].hClient      = 0;

	ItemDef[0].dwBlobSize   = 0;
	ItemDef[0].pBlob        = NULL;
	ItemDef[0].wReserved    = 0;
	
	// set the requeseted data type
	switch (item->req_data_type)
		{
		case Tango::DEV_DOUBLE:
			if ( use_array)
				ItemDef[0].vtRequestedDataType = VT_ARRAY | VT_R8;
			else
				ItemDef[0].vtRequestedDataType = VT_R8;
			break;
		
		case Tango::DEV_LONG:
			if ( use_array)
				ItemDef[0].vtRequestedDataType = VT_ARRAY | VT_I4;
			else
				ItemDef[0].vtRequestedDataType = VT_I4;
			break;
			
		case Tango::DEV_SHORT:
			if ( use_array)
				ItemDef[0].vtRequestedDataType = VT_ARRAY | VT_I2;
			else
				ItemDef[0].vtRequestedDataType = VT_I2;	
			break;
		}	

	// Create one item
	hr = m_IOPCItemMgt->AddItems(1, ItemDef, &pItemResult, &pErrors);
	free(bsItem);
	
	// OPC server access failed
	//
	
	if (FAILED(hr))
		{
		TangoSys_MemStream out_stream;
		out_stream << "Cannot access OPC server to create item " << frame << endl;
		Tango::Except::throw_exception(
							(const char *)"UNABLE_CREATE_ITEM",
							out_stream.str(),
							(const char *)"OPCaccess::CreateItem()");
		}

	// item creation failed
	//
		
	if (FAILED(pErrors[0]))
		{
		ERROR_STREAM << "OPCaccess::BuildItem(): AddItems failed!" << endl;
		ERROR_STREAM << "Error message : " << GetErrorString(pErrors[0]) << endl;
		
		item->itemHandle = NULL;
		item->connected  = false;
		}		
	else
		{
		// store the item handle
		item->itemHandle  = pItemResult[0].hServer;
		item->accessRight = pItemResult[0].dwAccessRights;
		item->connected  = true;
		
		// Free the memory allocated by the server
		for (i=0; i<1; i++)
			{
			if (pItemResult[i].pBlob)
				{
				::CoTaskMemFree(pItemResult[i].pBlob);
				pItemResult[i].pBlob = NULL;
				}
			}		
		} 
		
	// Free the server allocated memory
	
	::CoTaskMemFree(pItemResult);
	::CoTaskMemFree(pErrors);
}


//***********************************************************************************
// Read from an item
//***********************************************************************************
void OPCaccess::ReadItem (OpcItem *item)
{
	// to avoid overload, read an item only once a second
	//
	
	time_t now;
	time (&now);
	if ( (item->last_read_time + 1) < now )
		{	

		// Free the server allocated memory from the last call

		if ( item->pErrors != NULL )
			{
			::CoTaskMemFree(item->pErrors);
			item->pErrors    = NULL;
			}
		if ( item->pItemState != NULL )
			{
			::VariantClear(&(item->pItemState[0].vDataValue));
			::CoTaskMemFree(item->pItemState);
			item->pItemState = NULL;
			}

		if ((LPUNKNOWN)m_IOPCSyncIO != NULL)
			{
			// Call the read method
			HRESULT hr = m_IOPCSyncIO->Read (item->data_source, 1,
												&item->itemHandle, &item->pItemState,					
												&item->pErrors);
			
			// The access to the OPC server failed
			//			
			if (FAILED(hr))
				{
				TangoSys_MemStream out_stream;
				out_stream << "Cannot Read Items from OPC server " << endl;
				out_stream << "See device status for more information!" << ends;
				Tango::Except::throw_exception(
									(const char *)"UNABLE_READ_ITEM",
									out_stream.str(),
									(const char *)"OPCaccess::ReadItems()");
				}
			}
		else
			{
			TangoSys_MemStream out_stream;
			out_stream << "Cannot Read Items, IOPCSyncIO interface not allocated " << ends;
			Tango::Except::throw_exception(
									(const char *)"UNABLE_READ_ITEM",
									out_stream.str(),
									(const char *)"OPCaccess::ReadItems()");
			}

		item->last_read_time = now;
		}		
}


//***********************************************************************************
// Write synchronously the short item
//***********************************************************************************
void OPCaccess::WriteItem (OpcItem *item, short value)
{
	COleVariant	*var_val = new COleVariant(value);
	set_value (item, var_val);
	delete var_val;
}


//***********************************************************************************
// Write synchronously the long item
//***********************************************************************************
void OPCaccess::WriteItem (OpcItem *item, long value)
{
	COleVariant	*var_val = new COleVariant(value);
	set_value (item, var_val);
	delete var_val;
}


//***********************************************************************************
// Write synchronously the double item
//***********************************************************************************
void OPCaccess::WriteItem (OpcItem *item, double value)
{
	COleVariant	*var_val = new COleVariant(value);
	set_value (item, var_val);
	delete var_val;
}

//***********************************************************************************
//	Write the item value to the OPC item
//***********************************************************************************
void OPCaccess::set_value (OpcItem *item, COleVariant *var_val)
{
	HRESULT		*pErrors = NULL;

	if ((LPUNKNOWN)m_IOPCSyncIO != NULL)
		{
		// Call the write method
		
		HRESULT hr = m_IOPCSyncIO->Write(1,	&item->itemHandle, var_val, &pErrors);

		// The access to the OPC server failed
		//			
		if (FAILED(hr))
			{
			TangoSys_MemStream out_stream;
			out_stream << "Cannot write item to OPC server " << endl;
			out_stream << "See device status for more information!" << ends;
			Tango::Except::throw_exception(
								(const char *)"UNABLE_WRITE_ITEM",
								out_stream.str(),
								(const char *)"OPCaccess::WriteItem()");
			}
			
		if ( FAILED(pErrors[0]) )
			{
			TangoSys_MemStream out_stream;
			out_stream << "Cannot Write Item " << endl;
			out_stream << GetErrorString(pErrors[0]) << ends;
			Tango::Except::throw_exception(
							(const char *)"UNABLE_WRITE_ITEM",
							out_stream.str(),
							(const char *)"OPCaccess::WriteItem()");
			}
		}
	else
		{
		TangoSys_MemStream out_stream;
		out_stream << "Cannot write item, IOPCSyncIO interface not allocated " << ends;
		Tango::Except::throw_exception(
									(const char *)"UNABLE_WRITE_ITEM",
									out_stream.str(),
									(const char *)"OPCaccess::WriteItem()");
		}
}







//+------------------------------------------------------------------
/**
 *	method:	OPCaccess::start
 *
 *	description:	This is an internal method to create all
 *						necessary attributes for this device.
 *						The method is only executed once after the
 *                creation of the device.
 */
//+------------------------------------------------------------------
void OPCaccess::start()
{
	DEBUG_STREAM << "OPCaccess::start(): entering... !" << endl;

	//
	// loop over the list of attribute to be created!
	
	short	i;
	if ( create_flag == false )
		{
		for (i=0; i < opc_items.size(); i++)
			{
			OpcItem *item = &(opc_items[i]);
			
			try
				{
				get_device_attr()->get_attr_by_name (item->attr_name.c_str());
				}

			catch (...)
				{	
				// read a first set of data from the item

				ReadItem (item);
				
				// find the access to the item Read, Write or Read_Write
				
				Tango::AttrWriteType	attr_type = Tango::READ;
				if ( item->accessRight == (OPC_READABLE + OPC_WRITEABLE) )
					{
					attr_type = Tango::READ_WRITE;
					}
				else
					{
					if ( item->accessRight == OPC_WRITEABLE )
						{
						attr_type = Tango::WRITE;
						} 
					}

				// find out whether a scalar or a spectrum attribute must be 
				// created for an item.
				
				Tango::Attr *new_attr;
				long ubound = 0;
				
				// check array length only if array data type can be handled
				if ( use_array)
					SafeArrayGetUBound (item->pItemState[0].vDataValue.parray, 1, &ubound);
				
				if (ubound == 0)
					{
					new_attr = new OpcScalarAttrib (item->attr_name.c_str(), 
														    item->req_data_type,
														    attr_type);
					}
				else
					{
					new_attr = new OpcSpectrumAttrib (item->attr_name.c_str(),
																item->req_data_type, 
																(ubound + 1));		
					}
				add_attribute(new_attr);
				}			
			}
			
		create_flag = true;
		}
		
	return;	
}


//***********************************************************************************
// Get OPC error string
//***********************************************************************************
const char *OPCaccess::GetErrorString(HRESULT pErr)
{
	static char	str[0x80];
	LPWSTR err_wstr;

	HRESULT hr = m_IOPCServer->GetErrorString(pErr, LOCALE_SYSTEM_DEFAULT, &err_wstr);

	if (hr==S_OK)
	{
		int i;
		for (i=0 ; err_wstr[i] ; i++)
			str[i] = (char) err_wstr[i];
		str[i] = 0;
		cout2 << str << endl;
		::CoTaskMemFree(err_wstr);
		return str;
	}
	else
	{
		cout << "Error: " << hr  << endl;
		return "Cannot Create Error Description";
	}
}


}	//	namespace
