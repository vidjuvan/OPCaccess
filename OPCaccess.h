//=============================================================================
//
// file :        OPCaccess.h
//
// description : Include for the OPCaccess class.
//
// project :	A generic class to access OPC servers
//
// $Author: andy_gotz $
//
// $Revision: 1.1 $
//
// $Log: not supported by cvs2svn $
// Revision 1.3  2005/09/06 16:26:07  meyer
// Ported to Tango%. Modified attribute structure!
//
// Revision 1.2  2004/11/17 15:57:16  meyer
// Update documentation and added support for OPC servers without array handling.
//
// Revision 1.1.1.1  2004/11/08 09:21:08  meyer
// Imported using TkCVS
//
// Revision 1.6  2004/10/27 14:29:41  meyer
//  Tested version!
//
// Revision 1.5  2004/10/25 16:44:17  meyer
// Cleaned-up
//
// Revision 1.4  2004/10/25 16:07:19  meyer
// Tested per item access.
//
// Revision 1.3  2004/10/25 10:49:05  meyer
// OPC item as structure!
//
// Revision 1.2  2004/10/22 13:51:33  meyer
// *** empty log message ***
//
// Revision 1.1  2004/10/20 11:42:34  meyer
// Initial revision
//
//
// copyleft :    European Synchrotron Radiation Facility
//               BP 220, Grenoble 38043
//               FRANCE
//
//=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================
#ifndef _OPCACCESS_H
#define _OPCACCESS_H

#include <tango.h>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include <strstream>

#include "opcda.h"
#include "opccomn.h"
#include "interface.h"




//using namespace Tango;

/**
 * @author	$Author: andy_gotz $
 * @version	$Revision: 1.1 $ $
 */

 //	Add your own constants definitions here.
 //-----------------------------------------------

#define H_CLIENT_USE		10

// Item handles

typedef struct 
		{
		string 				item_name;
		string				attr_name;
		
		OPCHANDLE 			itemHandle;
		DWORD					accessRight;
		short					connected;
		OPCDATASOURCE		data_source;
		OPCITEMSTATE		*pItemState;
		HRESULT				*pErrors;
		time_t				last_read_time;
		long				req_data_type;
		} OpcItem;


namespace OPCaccess_ns
{

/**
 * Class Description:
 * The OPCaccess class maps data items from an OPC server to Tango
 *	attributes. For every OPCaccess device the attibute data type has
 *	to be specified. Tango can handle only double, long and short attributes.
 *	All OPC data items are casted to the requested data type.
 *	If an OPC item is an array (uses the ,lxx) extension in the item name,
 *	the tango attribute is created as a spectrum attibute.
 *	
 *	For OPC servers which cannot handle array types, the property
 *	"array_handling" must be set to false to trigger correct data conversion.
 */

/*
 *	Device States Description:
 *	Tango::UNKNOWN :	No connection to the OPC server
 *	Tango::ALARM :	One or more data items are invalid
 *	Tango::ON :	OPC server access is OK
 *	Tango::FAULT :	The used OPC server indicates a fault.
 */


class OPCaccess: public Tango::Device_4Impl
{
public :
	//	Add your own data members here
	//-----------------------------------------
	
	//Extract real attribute values from hardware acquisition result.
	virtual void read_attr(Tango::Attribute &attr);
	//Write attribute values to hardware.
	virtual void write_attr(Tango::WAttribute &attr);	
	
	void start();
	
	//	Here is the Start of the automatic code generation part
	//-------------------------------------------------------------	
/**
 *	@name attributes
 *	Attributs member data.
 */
//@{
//@}

/**
 *	@name Device properties
 *	Device properties member data.
 */
//@{
/**
 *	Triggers data reading from the OPC cache or directly from the OPC item.
 *	Set to 1 -> cache reading is enabled.
 *	Set to 0 -> direct access is enabled.
 */
	Tango::DevShort	dataFromCache;
/**
 *	Specifies the name of the OPC server to be used.
 */
	string	server_name;
/**
 *	Specifies the path of the OPC item to be addressed on the OPC server.
 */
	string	path_name;
/**
 *	Specifies the OPC item names to be read from the OPC server
 *	via the given path.
 */
	vector<string>	item_names;
/**
 *	This is set as the requested data type for the OPC items to be read.
 *	The possible data types are "double", "long" or "short".
 */
	string	data_type;
/**
 *	Specifies whether the OPC server used is capable to handle arrays or only
 *	scalar data types.
 *	array_handling = "true" , array data types are handled.
 *	array_handling = "false", only scalar data types are handled.
 */
	string	array_handling;
//@}

/**@name Constructors
 * Miscellaneous constructors */
//@{
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	OPCaccess(Tango::DeviceClass *cl,string &s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device Name
 */
	OPCaccess(Tango::DeviceClass *cl,const char *s);
/**
 * Constructs a newly allocated Command object.
 *
 *	@param cl	Class.
 *	@param s 	Device name
 *	@param d	Device description.
 */
	OPCaccess(Tango::DeviceClass *cl,const char *s,const char *d);
//@}

/**@name Destructor
 * Only one desctructor is defined for this class */
//@{
/**
 * The object desctructor.
 */	
	~OPCaccess() {delete_device();};
/**
 *	will be called at device destruction or at init command.
 */
	void delete_device();
//@}

	
/**@name Miscellaneous methods */
//@{
/**
 *	Initialize the device
 */
	virtual void init_device();
/**
 *	Always executed method befor execution command method.
 */
	virtual void always_executed_hook();

//@}

/**
 * @name OPCaccess methods prototypes
 */

//@{
/**
 *	Execution allowed for ReadCache command.
 */
	virtual bool is_ReadCache_allowed(const CORBA::Any &any){return true;};
/**
 *	Execution allowed for ReadDirect command.
 */
	virtual bool is_ReadDirect_allowed(const CORBA::Any &any){return true;};
/**
 * This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *	@return	State Code
 *	@exception DevFailed
 */
	virtual Tango::DevState	dev_state();
/**
 * This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *	@return	Status descrition
 *	@exception DevFailed
 */
	virtual Tango::ConstDevString	dev_status();
/**
 * Triggers reading of data from the OPC data cache.
 *	@exception DevFailed
 */
	void	read_cache();
/**
 * Triggers reading of data directly from the OPC item.
 *	@exception DevFailed
 */
	void	read_direct();

/**
 *	Read the device properties from database
 */
	 void get_device_property();
//@}

	//	Here is the end of the automatic code generation part
	//-------------------------------------------------------------	



protected :	
	//	Add your own data members here
	//-----------------------------------------
	
	void ConnectServer(const char *);
	void CreateGroup(const char *, const char *);
	void CreateItem(char *, long);
	void CreateItem(const char *, const char *);
	void BuildItem(char *, OpcItem *item);
	
	void ReadItem(OpcItem *item);
	void WriteItem (OpcItem *item, short  value);
	void WriteItem (OpcItem *item, long   value);
	void WriteItem (OpcItem *item, double value);	
	void set_value (OpcItem *item, COleVariant *var_val);	
	
	const char *GetErrorString(HRESULT);
	char *devname2grpname();
	
	// Server object interface ptr
	CInterface <IOPCServer, &IID_IOPCServer> m_IOPCServer;

	// Group object interface ptr
	CInterface<IOPCItemMgt, &IID_IOPCItemMgt> m_IOPCItemMgt;
	CInterface<IOPCSyncIO, &IID_IOPCSyncIO>   m_IOPCSyncIO;
	CInterface<IOPCGroupStateMgt, &IID_IOPCGroupStateMgt> m_IOPCGroupStateMgt;

	// Server handle of the group
	OPCHANDLE m_hServerGroup;
	// Connection
	DWORD     m_dwConnection;

	//COPCDataCallback *m_pCallback;	// IOPCDataCallback implementation
		
	vector <OpcItem>     opc_items;
	OPCDATASOURCE			data_source;
	long						req_data_type;
	short						use_array;
	short				      create_flag;
};

}	// namespace

#endif	// _OPCACCESS_H
